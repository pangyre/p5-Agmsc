#!/usr/bin/env perl
use warnings;
use strict;
use WWW::Mechanize;
use YAML;

my $agent = WWW::Mechanize->new;
my $agmsc = Agmsc->new({ root => "http://sedition.com",
                         agent => $agent }); # Profile def ? DB

$agmsc->add_to_queue($agmsc->root);
# Initialize step. Should be in build args.

while ( my $link = $agmsc->next_link )
{
    print $agmsc->get($link->uri)->freshness_lifetime, $/;
    print $link->due_for_checkup ? "DUE\n" : "not\n";
#    print YAML::Dump($agmsc->get($link->uri));
    # links in page


    # $agmsc->add_to_queu($link); # With check info.
}

exit 0;

#  Subroutines
#---------------------------------------------------------------------

BEGIN {
    package Agmsc;
    use Moose;
    use namespace::autoclean;
    our $VERSION = "0.01";
    use URI;
    use HTTP::Response;

    use Moose::Util::TypeConstraints;

    subtype "Agmsc::LinkType" => as class_type('Agmsc::Link');

    coerce "Agmsc::LinkType"
        => from "Str"
        => via { Agmsc::Link->new({ uri => URI->new($_) }) }
#        => from "Object"
#        => via { $_->isa("HTTP::Response") ?
#                 { $_->
#        }
        ;


    no Moose::Util::TypeConstraints;

    has "root" =>
        is => "ro",
        isa => "Agmsc::LinkType",
        coerce => 1,
        # isa => "ArrayRef[URI]",
        required => 1,
        #auto_deref => 1,
        ;

#    after "root" => sub {
#        my $self = shift;
#        $self->add_to_queue($self->root);
#    };

    has "exclude" =>
        is => "rw",
        isa => "RegexpRef", # ArrayRef[URI]
        ;

    has "include" =>
        is => "rw",
        isa => "RegexpRef", # ArrayRef[Agmsc::Inclusion]
        ;

    has "agent" =>
        is => "ro",
        isa => "LWP::UserAgent", # ArrayRef[URI]
        handles => {
            get => "get",
        }
        ;

    has "links" =>
        is => "rw",
        isa => "ArrayRef[Agmsc::Link]",
        auto_deref => 1,
        ;

    has "queue" =>
        traits => [ "Array" ],
        is => "rw",
        isa => "ArrayRef[Agmsc::Link]",
        auto_deref => 1,
        lazy => 1,
        default => sub { [] },
        handles => {
            next_link => "shift",
            add_to_queue => "push",
        }
        ;

    __PACKAGE__->meta->make_immutable();


    package Agmsc::Link;
    use Moose;
    use namespace::autoclean;
    use overload '""' => sub { return +shift->uri->as_string }, fallback => 1;

#?    use URI;

    has "uri" =>
        is => "ro",
        isa => "URI",
        required => 1,
        handles => [qw/
            protocol
            host
            path
            fragment
            query_string
        /]
        ;

    package Agmsc::LinkCheck;
    use Moose;
    use namespace::autoclean;

    has "response" =>
        is => "ro",
        isa => "HTTP::Response",
        required => 1,
        handles => {
            status => "code",
            content => "decoded_content",
            base => "base",
            freshness_lifetime => "freshness_lifetime",
        }
        ;

    has "time" =>
        is => "ro",
        required => 1,
        default => sub { time() },
        ;

    # this has to go in Link and be run on the end of its LinkCheck array.
    sub due_for_checkup {
        my $self = shift;
        ( $self->time - time() ) > $self->freshness_lifetime
    }

    has "links" =>
        is => "rw",
        isa => "ArrayRef[Agmsc::Link]",
        auto_deref => 1,
        ;

    has "parents" =>
        is => "rw",
        isa => "ArrayRef[Agmsc::Link]",
        auto_deref => 1,
        weak_ref => 1,
        ;

    # Role for this stuff?

    use HTTP::Date;
    use DateTime;

    sub resident {
        my $self = shift;
    }

    sub content_type {
        +shift->headers->header("Content-Type");
    }

    sub content_length {
        +shift->headers->header("Content-Length");
    }

    sub last_modified {
        my $time = str2time( +shift->headers->header("Last-Modified") );
        DateTime->from_epoch( epoch => $time );
    }

    sub expires {
        my $time = str2time( +shift->headers->header("Expires") );
        DateTime->from_epoch( epoch => $time );
    }


    __PACKAGE__->meta->make_immutable();

}

__DATA__

 
